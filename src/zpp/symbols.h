#ifndef _ZPP_SYMBOLS_H_
#define _ZPP_SYMBOLS_H_

#include "lists.h"
#include "syntax_tree.h"

// Describes what type of symbol something is
typedef enum zpp_symbol_type
{
	ZPP_SYMBOL_PACKAGE,
	ZPP_SYMBOL_FUNC,
	ZPP_SYMBOL_CONST,
	ZPP_SYMBOL_TYPE,
	ZPP_SYMBOL_GLOBAL,
	ZPP_SYMBOL_LOCAL,
	ZPP_SYMBOL_ARGUMENT,
	ZPP_SYMBOL_RETURN,
	
	// An unresolved symbol. This is normally used for when you are referring to
	// something before it's declared by the developer
	ZPP_SYMBOL_UNRESOLVED
} zpp_symbol_type;

// Represents a symbol, such as a package or a function
typedef struct zpp_symbol
{
	// Type of symbol
	zpp_symbol_type type;
	// The name of this symbol
	vm_string name;
	// This symbol is initialized
	BOOL initialized;
} zpp_symbol, zpp_symbol_header;

// Get the base class for a specific symbol
#define ZPP_SYMBOL(s) (&s->header)

// Initialize the supplied symbol
extern void zpp_symbol_init(zpp_symbol_header* s, zpp_symbol_type type);

// Check to see if the supplied symbol has the name
extern BOOL zpp_symbol_has_name(zpp_symbol* s, const vm_string* name);

// The package
typedef struct zpp_package
{
	zpp_symbol header;

	// Parent package
	struct zpp_package* parent;

	// Child packages
	struct zpp_package* children;
	struct zpp_package* children_end;

	// Types part of this package
	struct zpp_type* types;
	struct zpp_type* types_end;

	// Functions part of this package
	struct zpp_func* funcs;
	struct zpp_func* funcs_end;

	// Intrusive linked list
	struct zpp_package* head;
	struct zpp_package* tail;

	vmp_package* package;
} zpp_package;

// Flags that helps describe a specific type
typedef enum zpp_type_flag
{
	ZPP_TYPE_FLAG_PTR = 1 << 0,
	ZPP_TYPE_FLAG_ARRAY = 1 << 1,
} zpp_type_flag;

// Represents a type
typedef struct zpp_type
{
	zpp_symbol header;

	// The package this type is part of
	zpp_package* package;

	// The size of this type
	vm_int32 size;

	// Flags
	vm_bits32 flags;

	// What type of underlying datatype is this considered to be
	vm_uint8 data_type;

	// If this type is of another type. Normally used for pointer- and array types
	struct zpp_type* of_type;

	// What this type is inherited from
	zpp_inherits_from inherits_from;

	// What types this type is inherited by
	zpp_inherited_by inherited_by;

	// Intrusive linked list
	struct zpp_type* head;
	struct zpp_type* tail;

	// The type, cached, so that we can much faster reuse it later on. This is realized after the parsing is done
	// and the actual compilation has started
	vmp_type* type;
} zpp_type;

// Structure used to help creating a type
typedef struct zpp_type_props
{
	vm_string name;
	vm_uint32 size;
	vm_uint32 flags;
	vm_uint8 data_type;
	zpp_type* of_type;
} zpp_type_props;

// An argument
typedef struct zpp_argument
{
	zpp_symbol header;

	// The expected argument type
	zpp_symbol* type;

	// Intrusive linked list
	struct zpp_argument* head;
	struct zpp_argument* tail;

	// The argument. Freeing memory of this is done by the pipeline and not this type
	vmp_arg* arg;
} zpp_argument;

// A local variable
typedef struct zpp_local
{
	zpp_symbol header;

	// The expected argument type
	zpp_symbol* type;

	// Intrusive linked list
	struct zpp_local* head;
	struct zpp_local* tail;

	// The local. Freeing memory of this is done by the pipeline and not this type
	vmp_local* local;
} zpp_local;

// A return value
typedef struct zpp_return
{
	zpp_symbol header;
	
	// The return type returned
	zpp_symbol* type;

	// Intrusive linked list
	struct zpp_return* head;
	struct zpp_return* tail;

	// The return value. Freeing memory of this is done by the pipeline and not this type
	vmp_return* ret;
} zpp_return;

typedef enum zpp_func_flags
{
	// This function is public and can be accessed outside the package
	ZPP_FUNC_FLAG_PUBLIC = (1 << 0),

	// This function is marked as an external function. This means that the function
	// has to be linked from a c source code
	ZPP_FUNC_FLAG_EXTERN = (1 << 1),

	// This function is a lambda function
	ZPP_FUNC_FLAG_LAMBDA = (1 << 2),

	// The function is generated by the compiler. This type of function is
	// not visible outside the compiler
	ZPP_FUNC_FLAG_GENERATED = (1 << 3),
} zpp_func_flags;

// The function
typedef struct zpp_func
{
	zpp_symbol header;

	// Package this function is part of
	zpp_package* package;

	// All arguments required by this function
	zpp_argument* arguments;
	zpp_argument* arguments_end;
	vm_int32 arguments_count;

	// All return values returned by this function
	zpp_return* returns;
	zpp_return* returns_end;
	vm_int32 returns_count;

	// All local variables
	zpp_local* locals;
	zpp_local* locals_end;

	// Syntax tree
	struct zpp_syntax_tree* syntax_tree;
	struct zpp_syntax_tree* syntax_tree_end;

	// Intrusive linked list
	struct zpp_func* head;
	struct zpp_func* tail;

	// Function. Freeing memory of this is done by the pipeline and not this type
	vmp_func* func;
} zpp_func;

// Fetch a properties object that can be used to create a new type
extern const zpp_type_props* zpp_type_props_get(const vm_string* name, vm_uint32 size, vm_uint32 flags, vm_uint8 data_type, zpp_type* of_type);

// Create a new type.
// TODO Make it possible to create a new zpp type based on a vmp type
extern zpp_type* zpp_type_new(const vm_string* name);

// Create a new type from a properties structure
extern zpp_type* zpp_type_new_from_props(const zpp_type_props* props);

// Destroy the supplied type
extern void zpp_type_destroy(zpp_type* p);

// Resolve the supplied type and get the type
extern vmp_type* zpp_type_resolve_type(zpp_type* t, struct zpp_compiler* c);

// Initialize the underlying pipeline type
extern BOOL zpp_type_initialize_type(zpp_type* t, struct zpp_compiler* c);

// Create a new package
extern zpp_package* zpp_package_new(const vm_string* name);

// Destroy the supplied package
extern void zpp_package_destroy(zpp_package* ptr);

// Resolve the supplied type and get the type
extern vmp_package* zpp_package_resolve_package(zpp_package* p, struct zpp_compiler* c);

// Search for a function
extern zpp_func* zpp_package_find_func(zpp_package* p, const vm_string* name);

// Search for a type
extern zpp_type* zpp_package_find_type(zpp_package* p, const vm_string* name);

// Search for a generic symbol. It might be a function, type, constant or global variable
extern zpp_symbol* zpp_package_find_symbol(zpp_package* p, const vm_string* name);

// Result of when adding an item
typedef enum zpp_package_add_result
{
	// Add failed because out of memory
	ZPP_PACKAGE_ADD_OUT_OF_MEMORY = 0,
	// The item already exist
	ZPP_PACKAGE_ADD_DUPLICATE = 1,
	// Add successfully
	ZPP_PACKAGE_ADD_ADDED = 2
} zpp_package_add_result;

// Add a type in the supplied package. If the return value is non-zero then the type exists in the package. If the value
// is VMCD_PACKAGE_ADD_DUPLICATE then the item is already added
extern zpp_package_add_result zpp_package_add_type(zpp_package* p, zpp_type* t);

// Add a function in the supplied package. If the return value is non-zero then the function exists in the package. If the value
// is VMCD_PACKAGE_ADD_DUPLICATE then the item is already added
extern zpp_package_add_result zpp_package_add_func(zpp_package* p, zpp_func* f);

// Create a new function
extern zpp_func* zpp_func_new(const vm_string* name);

// Destroy the supplied function
extern void zpp_func_destroy(zpp_func* f);

// Add a syntax tree node to the supplied function
extern void zpp_func_add_syntax_tree(zpp_func* f, zpp_syntax_tree_node node);

// Add the supplied argument
extern void zpp_func_add_argument(zpp_func* f, zpp_argument* a);

// Add the supplied return value
extern void zpp_func_add_return(zpp_func* f, zpp_return* r);

// Add the supplied local value
extern void zpp_func_add_local(zpp_func* f, zpp_local* l);

// Resolve the supplied type and get the type
extern vmp_func* zpp_func_resolve_func(zpp_func* f, struct zpp_compiler* c);

// Search for a local variable in this function
extern zpp_local* zpp_func_find_local(zpp_func* f, const vm_string* name);

// Search for an argument of a specific name
extern zpp_argument* zpp_func_find_argument(zpp_func* f, const vm_string* name);

// Search for a symbol variable in this function
extern zpp_symbol* zpp_func_find_symbol(zpp_func* f, const vm_string* name);

// Return how many arguments are part of the function
extern vm_int32 zpp_func_num_arguments(zpp_func* f);

// Return how many arguments are part of the function
extern vm_int32 zpp_func_num_returns(zpp_func* f);

// Create a new arg
extern zpp_argument* zpp_argument_new(const vm_string* name);

// Destroy the supplied arg
extern void zpp_argument_destroy(zpp_argument* ptr);

// Create a new ret
extern zpp_return* zpp_return_new();

// Destroy the supplied ret
extern void zpp_return_destroy(zpp_return* ptr);

// Resolve a type based on a specific symbol
extern vmp_type* zpp_symbol_resolve_type(zpp_symbol* s, struct zpp_compiler* c);

// Create a new local variable
extern zpp_local* zpp_local_new(const vm_string* name);

// Destroy the supplied local
extern void zpp_local_destroy(zpp_local* ptr);

#endif
